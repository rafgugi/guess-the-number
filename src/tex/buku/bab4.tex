\chapter{HASIL DAN PEMBAHASAN}

Bab ini memaparkan tentang hasil dan pembahasan pada metode-metode yang digunakan pada penelitian ini.

\section{Lingkungan Uji Coba}

Uji coba dilakukan pada perangkat dengan spesifikasi berikut.

\begin{enumerate}
  \item Perangkat Keras
  \begin{enumerate}
    \item Processor Intel® Core™ i7-7400 CPU @ 3.00GHz (4 CPUs), ~3.0GHz
    \item Random Access Memory 8192MB
  \end{enumerate}
  \item Perangkat Lunak
  \begin{enumerate}
    \item Sistem Operasi Linux Ubuntu 16.04
    \item Bahasa Pemrograman C++
    \item gcc 5.4.0
  \end{enumerate}
\end{enumerate}


\section{Penyelesaian menggunakan repetisi pencarian biner}

Algoritma repetisi pencarian biner menghasilkan maksimal sebanyak $\log_2(M) \cdot (2e + 1)$ query non interaktif pada setiap kasus uji. Algoritma pencarian biner ada pada Kode Sumber \ref{alg:repetisi_biner}. Baris \ref{alg:for_qb} menunjukkan perulangan untuk setiap jenis query $qb$. Nilai $qb$ adalah hasil $\log_2$ dari M, lalu dibulatkan ke atas karena $M$ harus merupakan perpangkatan dari 2 sehingga nilai $qb = \text{ceil}(\log_2(M))$. Baris \ref{alg:for_m} menunjukkan perulangan untuk membuat setiap satu jenis query pencarian biner. Baris \ref{alg:find_bit} menunjukkan proses untuk mencari bit pada posisi tertentu pada sebuah integer \cite{bithack}. Setiap query akan diulang sebanyak $qe$ seperti yang ditunjukkan pada baris \ref{alg:for_qe}.

\begin{algorithm}[h]
\caption{Algoritma repetisi pencarian biner}
\label{alg:repetisi_biner}
\Fn{repetitive\_binary\_search($M$, $e$)}{
\KwData{$M$ search space, $e$ max lies allowed}
\KwResult{$queries$}
  $queries = [\ ]$\;
  $qb = \text{ceil}(\log_2(M))$\;
  $qe = 2*e + 1$\;
  $twopower = 1$\;
  \For{$i = 0$ \KwTo $qb$}{\label{alg:for_qb}
    $string = ""$\;
    \For{$j = 0$ \KwTo $M$}{\label{alg:for_m}
      \eIf{$j\ \&\ twopower$}{\label{alg:find_bit}
        $string \mathrel{+}= "1"$\;
      }{
        $string \mathrel{+}= "0"$\;
      }
    }
    \For{$j = 0$ \KwTo $qe$}{\label{alg:for_qe}
      $queries$.push($string$)\;
    }
    $twopower \mathrel{*}= 2$\;
  }
  \Return $queries$\;
}
\end{algorithm}

\subsection{Skenario Uji Coba}

Subbab ini akan menjelaskan hasil pengujian program penyelesaian permasalahan. Algoritma disubmit ke SPOJ dalam bahasa C, menghasilkan penilaian yang ditunjukkan pada Tabel \ref{tab:score_repetitive}. Karena ini adalah algoritma yang pasti benar dengan cara termudah, maka dapat diasumsikan bahwa skor yang didapat dari algoritma ini adalah skor minimal yang dapat menjadi tolok ukur keberhasilan algoritma yang lain.

\begin{table}[h!]
\caption{Hasil algoritma repetisi pencarian biner pada SPOJ}
\label{tab:score_repetitive}
\begin{center}
\begin{tabular} {|l|l|}
\hline
ID & 20152331 \\ \hline
Tanggal & 2017-09-14 06:08:19 \\ \hline
Skor & 42,787,090 \\ \hline
Waktu & 0.00 \\ \hline
Memori & 2.7M \\ \hline
\end{tabular}
\end{center}
\end{table}


\section{Penyelesaian menggunakan pembobotan Berlekamp}

Pada algoritma menggunakan pembobotan juga akan dibuat query non interaktif pada setiap kasus uji. Sebanyak $\log_2(M)$ query awal adalah query biner. Selanjutnya mencari query dengan pendekatan berlekamp, yaitu mencari $\Delta_j$ terkecil seperti pada Persamaan \ref{eq:deltaj}.

\begin{algorithm}[h]
\caption{Algoritma pembobotan Berlekamp}
\label{alg:bobot_berlekamp}
\Fn{berlekamp\_weight($M$, $e$)}{
\KwData{$M$ search space, $e$ max lies allowed}
\KwResult{$queries$}
  $V = \text{make\_variation}(M)$\;\label{alg:make_varies}
  $C = \text{make\_channel}(M,e)$\;\label{alg:init_channel}
  $n = \text{ch}(C)$\label{alg:init_ch}
  \While{true}{\label{alg:brute}
  }
  \Return $queries$\;
}
\end{algorithm}

Langkah pertama adalah menggenerate $\mathcal{V}$ seperti pada baris \ref{alg:make_varies}, di mana $\mathcal{V}$ adalah semua variasi query yang paling mungkin digunakan untuk diajukan sebagai query. Jumlah $\mathcal{V}$ adalah $2^n$. Namun dapat $\mathcal{V}$ dioptimasi dengan cara hanya menggunakan query dengan jumlah \texttt{1} dan \texttt{0} sama atau selisih satu. Lalu hapus juga query yang saling berkebalikan. Misalnya \texttt{0011} berkebalikan dengan \texttt{1100}, \texttt{0101} berkebalikan dengan \texttt{1010}, dan sebagainya. Dengan begitu jumlah $\mathcal{V}$ adalah seperti pada Persamaan \ref{eq:varcount}.

\begin{equation}
\label{eq:varcount}
|\mathcal{V}| = \begin{dcases}
  \binom{M}{M/2} / 2, & \text{jika } M \text{ genap} \\
  \binom{M}{M/2} / 2 + \binom{M-1}{M/2 + 1}, & \text{jika } M \text{ ganjil}
\end{dcases}
\end{equation}

Langkah kedua adalah buat kanal $C$ dengan state awal $\{M,\underbrace{0,\ldots,0}_e\}$ seperti pada \ref{alg:init_channel}. Lalu cari nilai $n$ yaitu jumlah query yang akan diberikan dengan menggunakan Persamaan \ref{eq:character} seperti pada baris \ref{alg:init_ch}.

Langkah ketiga adalah pada sebuah state, cari sebuah query dari $\mathcal{V}$ di mana menghasilkan nilai berlekamp yang memiliki $\Delta_j$ terkecil seperti pada baris \ref{alg:brute}. Asumsikan semua jawaban dari sebuah query adalah "ya" karena permainan ini bersifat non-interaktif dan penjawab dapat menjawab apapun.

Query tersebut lalu divariasikan variasi biner sebanyak $\log_2(M)$ untuk dapat mengatasi segala kemungkinan state. Misal jika query tersebut adalah \texttt{000111}, maka akan divariasikan menjadi \texttt{00001111}, \texttt{00110011}, dan \texttt{01010101}.

Ulangi langkah ketiga sampai vector hanya berisi sebuah angka \texttt{1} dan sisanya berisi \texttt{0}. Setap melakukan langkah ketiga akan menghasilkan $\log_2(M)$ query.

**Kelemahan** propose method ini adalah masih menggunakan combinatoric untuk menghasilkan $\mathcal{V}$. Dengan maksimal jumlah $n = 4096$ akan menghasilkan jumlah $\mathcal{V}$ sebanyak $\binom{4096}{2048} / 2$. Oleh karena itu perlu menggenerate $\mathcal{V}$ yang lebih sedikit namun yang paling optimal.

Sedikit mengatasi kelemahan, variasi tidak perlu digenerate dari awal program dijalankan. Kita tinggal hanya memotong setiap channel menjadi mendekati setengah dari nilai sebelumnya. Namun masalahnya adalah jika nilai pada sebuah channel ganjil, maka kita tidak dapat memotongnya menjadi setengah. Pada saat itu lah kita akan mencoba setiap nilai menjadi $\text{floor}(\text{Ch}(i) / 2)$ atau $\text{floor}(\text{Ch}(i) / 2) + 1$.

\section{Penyelesaian menggunakan kode biner}
